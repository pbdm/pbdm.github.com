## 数据收集

* 客户端点击进入 webview  
  两种统计方式, 一种是客户端直接发打点给服务端,一种是将时间戳传给 h5

* 白屏时间：  
  ~~用户从打开页面开始到页面开始有东西呈现为止，这过程中占用的时间就是白屏时间~~  
  在 react 里应该是和用户可操作时间一样, 因为js 是在 body底部而不是 head 底部, 且DOM 是由 js 渲染的
```javascript
<!DOCTYPE HTML>
<html>
  <head>
    <script>
      window.perf = {}
      perf.startTime = +new Date
      console.log('start', +new Date - perf.startTime);
    </script>
    <script src="example.js"></script>
    <script>
      // head里所有的 script 都下载完后才会执行
      console.log('head end', +new Date - perf.startTime);
    </script>
  </head>
  <body>
    <p>test</p>
  </body>
  <script>
    console.log('htmlend', +new Date - perf.startTime)
  </script>
</html>
```

* 首屏时间  
  用户浏览器首屏内所有内容都呈现出来所花费的时间  
  需要绑定所有图片的 load 事件, 判断图片是否在首屏显示, 取 load 最晚的值

* 用户可操作时间：用户可以进行正常的点击、输入等操作
```
document.addEventListener('DOMContentLoaded', () => {
  console.log('DOMContentLoaded', +new Date - perf.startTime)
})
```

* 页面总下载时间：页面所有资源(非异步)都加载完成并呈现出来所花的时间，即页面 onload 的时间
```
window.addEventListener('load', function() {
  console.log('onload', +new Date - perf.startTime)
  // make log here
})
```
> http://fex.baidu.com/blog/2014/05/build-performance-monitor-in-7-days/

* chrome里可以使用 `performance.timing`
```javascript
  var t = performance.timing;
  var times = {};
  //【重要】页面加载完成的时间
  //【原因】这几乎代表了用户等待页面可用的时间
  times.loadPage = t.loadEventEnd - t.navigationStart;

  //【重要】解析 DOM 树结构的时间
  //【原因】反省下你的 DOM 树嵌套是不是太多了！
  times.domReady = t.domComplete - t.responseEnd;

  //【重要】重定向的时间
  //【原因】拒绝重定向！比如，http://example.com/ 就不该写成 http://example.com
  times.redirect = t.redirectEnd - t.redirectStart;

  //【重要】DNS 查询时间
  //【原因】DNS 预加载做了么？页面内是不是使用了太多不同的域名导致域名查询的时间太长？
  // 可使用 HTML5 Prefetch 预查询 DNS ，见：[HTML5 prefetch](http://segmentfault.com/a/1190000000633364)
  times.lookupDomain = t.domainLookupEnd - t.domainLookupStart;

  //【重要】读取页面第一个字节的时间
  //【原因】这可以理解为用户拿到你的资源占用的时间，加异地机房了么，加CDN 处理了么？加带宽了么？加 CPU 运算速度了么？
  // TTFB 即 Time To First Byte 的意思
  // 维基百科：https://en.wikipedia.org/wiki/Time_To_First_Byte
  times.ttfb = t.responseStart - t.navigationStart;

  //【重要】内容加载完成的时间
  //【原因】页面内容经过 gzip 压缩了么，静态资源 css/js 等压缩了么？
  times.request = t.responseEnd - t.requestStart;

  //【重要】执行 onload 回调函数的时间
  //【原因】是否太多不必要的操作都放到 onload 回调函数里执行了，考虑过延迟加载、按需加载的策略么？
  times.loadEvent = t.loadEventEnd - t.loadEventStart;

  // DNS 缓存时间
  times.appcache = t.domainLookupStart - t.fetchStart;

  // 卸载页面的时间
  times.unloadEvent = t.unloadEventEnd - t.unloadEventStart;

  // TCP 建立连接完成握手的时间
  times.connect = t.connectEnd - t.connectStart;
```
> http://caniuse.com/#search=timing  
> http://www.alloyteam.com/2015/09/explore-performance/

跳转 url 后记得要置零 `perf.startTime = +new Date`  
运维在这里的角色?!(监控接口返回时间)


## 数据落地

* 基于 bi 的打点系统, (echarts)?
* 数据分析  
  白屏(可操作), 首屏, 总下载


## 参数
* 时间点 (start, headend, indexstart, indexend, htmlend, DOMContentLoaded(白屏时间), onload, api 请求时间)
* 距离开始时间值
* 页面 url
* 机型参数,版本
* 网络参数,网络供应商


## 第三方工具

> https://gtmetrix.com/  
> http://www.mmtrix.com/


## 报错分析
在 index.js 里用 try catch 包裹,已在线上, 需要数据分析, sourcemap  
try catch：
* 无法捕捉到语法错误，只能捕捉运行时错误；
* 可以拿到出错的信息，堆栈，出错的文件、行号、列号；
* 需要借助工具把所有的function块以及文件块加入try,catch，可以在这个阶段打入更多的静态信息。

window.onerror：
* 可以捕捉语法错误，也可以捕捉运行时错误；
* 可以拿到出错的信息，堆栈，出错的文件、行号、列号；
* 只要在当前页面执行的js脚本出错都会捕捉到，例如：浏览器插件的javascript、或者flash抛出的异常等。
* 跨域的资源需要特殊头部支持。

异步方法如何 try catch?  
window.onerror (safari 里上报不全, 没有line, column, errorObject)
> http://doc.pajk-ent.com/pages/viewpage.action?pageId=24117480  
> http://www.cnblogs.com/hustskyking/p/fe-monitor.html  
> https://getsentry.com/welcome/  
> http://rapheal.sinaapp.com/2014/11/06/javascript-error-monitor/  


## 问题

样本量庞大,收集的时候是否需要过滤?
